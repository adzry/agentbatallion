/**
 * Backend Engineer Agent
 * 
 * Responsible for:
 * - Database schema design (Prisma)
 * - API route generation
 * - Server-side logic
 * - Authentication setup
 * - Data validation
 */

import { v4 as uuidv4 } from 'uuid';
import { BaseTeamAgent } from '../base-team-agent.js';
import {
  AgentProfile,
  AgentTask,
  Requirement,
  ArchitectureSpec,
  DataModel,
  ProjectFile,
} from '../types.js';
import { MemoryManager } from '../../memory/memory-manager.js';
import { ToolRegistry } from '../../tools/tool-registry.js';
import { MessageBus } from '../../communication/message-bus.js';

export interface BackendOutput {
  schema: string;
  apiRoutes: ProjectFile[];
  middleware: ProjectFile[];
  utils: ProjectFile[];
}

export class BackendEngineerAgent extends BaseTeamAgent {
  constructor(memory: MemoryManager, tools: ToolRegistry, messageBus: MessageBus) {
    const profile: AgentProfile = {
      id: 'backend-engineer-agent',
      name: 'Morgan',
      role: 'backend_engineer',
      avatar: 'üóÑÔ∏è',
      description: 'Backend Engineer - Builds robust server-side systems',
      capabilities: {
        canWriteCode: true,
        canDesign: true,
        canTest: true,
        canDeploy: false,
        canResearch: true,
        canReview: true,
        languages: ['TypeScript', 'SQL', 'Python'],
        frameworks: ['Next.js API', 'Prisma', 'tRPC', 'Express'],
      },
      personality: 'Systematic and security-conscious. Focuses on data integrity and API design.',
      systemPrompt: `You are Morgan, an experienced Backend Engineer AI agent.
Your responsibilities:
1. Design database schemas using Prisma
2. Create API routes with proper validation
3. Implement authentication and authorization
4. Set up server-side utilities
5. Ensure data integrity and security

Best practices:
- Use TypeScript for type safety
- Implement proper error handling
- Validate all inputs with Zod
- Follow RESTful API conventions
- Use proper HTTP status codes
- Implement rate limiting
- Secure sensitive endpoints`,
    };

    super(profile, memory, tools, messageBus);
  }

  /**
   * Generate backend code based on requirements and data models
   */
  async generateBackend(
    requirements: Requirement[],
    dataModels: DataModel[],
    architecture: ArchitectureSpec
  ): Promise<BackendOutput> {
    this.updateStatus('working');
    this.think('Analyzing data models for schema generation...');

    const files: {
      schema: string;
      apiRoutes: ProjectFile[];
      middleware: ProjectFile[];
      utils: ProjectFile[];
    } = {
      schema: '',
      apiRoutes: [],
      middleware: [],
      utils: [],
    };

    // Generate Prisma schema
    this.think('Generating Prisma schema...');
    files.schema = await this.act('code', 'Generating Prisma schema', async () => {
      return this.generatePrismaSchema(dataModels);
    });
    this.updateProgress(25);

    // Generate API routes
    this.think('Creating API routes...');
    files.apiRoutes = await this.act('code', 'Generating API routes', async () => {
      return this.generateApiRoutes(dataModels, requirements);
    });
    this.updateProgress(50);

    // Generate middleware
    this.think('Setting up middleware...');
    files.middleware = await this.act('code', 'Generating middleware', async () => {
      return this.generateMiddleware(requirements);
    });
    this.updateProgress(75);

    // Generate utilities
    this.think('Creating backend utilities...');
    files.utils = await this.act('code', 'Generating utilities', async () => {
      return this.generateUtils();
    });
    this.updateProgress(100);

    // Create artifacts
    this.createArtifact('code', 'Prisma Schema', files.schema, 'prisma/schema.prisma');
    for (const file of [...files.apiRoutes, ...files.middleware, ...files.utils]) {
      this.createArtifact('code', file.path.split('/').pop() || '', file.content, file.path);
    }

    this.updateStatus('complete');
    return files;
  }

  protected async executeTask(task: AgentTask): Promise<any> {
    switch (task.title) {
      case 'generate_backend':
        const reqs = await this.memory.recall('requirements', 20);
        const models = await this.memory.recall('data_models', 20);
        const arch = await this.memory.recall('architecture', 1);
        return await this.generateBackend(
          reqs as Requirement[],
          models as DataModel[],
          arch[0] as ArchitectureSpec
        );
      default:
        throw new Error(`Unknown task: ${task.title}`);
    }
  }

  private generatePrismaSchema(dataModels: DataModel[]): string {
    let schema = `// Prisma Schema
// Generated by Agent Battalion - Backend Engineer

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

`;

    // Always include User model for auth
    const hasUser = dataModels.some(m => m.name === 'User');
    if (!hasUser) {
      schema += `model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  password  String?
  image     String?
  role      Role     @default(USER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}

enum Role {
  USER
  ADMIN
}

`;
    }

    // Generate models from data models
    for (const model of dataModels) {
      schema += `model ${model.name} {\n`;
      
      for (const field of model.fields) {
        const prismaType = this.mapToPrismaType(field.type);
        const modifiers: string[] = [];
        
        if (field.unique) modifiers.push('@unique');
        if (field.name === 'id') modifiers.push('@id @default(cuid())');
        if (field.name === 'createdAt') modifiers.push('@default(now())');
        if (field.name === 'updatedAt') modifiers.push('@updatedAt');
        
        const optional = field.required ? '' : '?';
        const modifierStr = modifiers.length > 0 ? ' ' + modifiers.join(' ') : '';
        
        schema += `  ${field.name.padEnd(12)} ${prismaType}${optional}${modifierStr}\n`;
      }
      
      // Add relations if defined
      if (model.relations) {
        schema += '\n';
        for (const rel of model.relations) {
          if (rel.type === 'one-to-many') {
            schema += `  ${rel.field.padEnd(12)} ${rel.target}[]\n`;
          } else {
            schema += `  ${rel.field.padEnd(12)} ${rel.target}?\n`;
          }
        }
      }
      
      schema += `\n  @@map("${model.name.toLowerCase()}s")\n}\n\n`;
    }

    return schema;
  }

  private mapToPrismaType(type: string): string {
    const typeMap: Record<string, string> = {
      'string': 'String',
      'number': 'Int',
      'float': 'Float',
      'boolean': 'Boolean',
      'date': 'DateTime',
      'Date': 'DateTime',
      'json': 'Json',
      'text': 'String',
    };
    return typeMap[type.toLowerCase()] || 'String';
  }

  private generateApiRoutes(dataModels: DataModel[], requirements: Requirement[]): ProjectFile[] {
    const routes: ProjectFile[] = [];

    // Health route
    routes.push({
      path: 'app/api/health/route.ts',
      content: `import { NextResponse } from 'next/server';

export async function GET() {
  return NextResponse.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    version: process.env.npm_package_version || '1.0.0',
  });
}
`,
      type: 'source',
      createdBy: this.profile.id,
      createdAt: new Date(),
      updatedAt: new Date(),
      version: 1,
    });

    // Generate CRUD routes for each model
    for (const model of dataModels) {
      const modelLower = model.name.toLowerCase();
      
      // List and Create route
      routes.push({
        path: `app/api/${modelLower}s/route.ts`,
        content: this.generateListCreateRoute(model),
        type: 'source',
        createdBy: this.profile.id,
        createdAt: new Date(),
        updatedAt: new Date(),
        version: 1,
      });

      // Get, Update, Delete route
      routes.push({
        path: `app/api/${modelLower}s/[id]/route.ts`,
        content: this.generateCrudRoute(model),
        type: 'source',
        createdBy: this.profile.id,
        createdAt: new Date(),
        updatedAt: new Date(),
        version: 1,
      });
    }

    // Auth routes if needed
    const needsAuth = requirements.some(r => 
      r.description.toLowerCase().includes('auth') || 
      r.description.toLowerCase().includes('login')
    );

    if (needsAuth) {
      routes.push({
        path: 'app/api/auth/register/route.ts',
        content: this.generateAuthRegisterRoute(),
        type: 'source',
        createdBy: this.profile.id,
        createdAt: new Date(),
        updatedAt: new Date(),
        version: 1,
      });

      routes.push({
        path: 'app/api/auth/login/route.ts',
        content: this.generateAuthLoginRoute(),
        type: 'source',
        createdBy: this.profile.id,
        createdAt: new Date(),
        updatedAt: new Date(),
        version: 1,
      });
    }

    return routes;
  }

  private generateListCreateRoute(model: DataModel): string {
    const modelName = model.name;
    const modelLower = model.name.toLowerCase();

    return `import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { z } from 'zod';

// Validation schema
const create${modelName}Schema = z.object({
${model.fields
  .filter(f => !['id', 'createdAt', 'updatedAt'].includes(f.name))
  .map(f => `  ${f.name}: z.${this.mapToZodType(f.type)}()${f.required ? '' : '.optional()'},`)
  .join('\n')}
});

// GET - List all ${modelLower}s
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '10');
    const skip = (page - 1) * limit;

    const [${modelLower}s, total] = await Promise.all([
      prisma.${modelLower}.findMany({
        skip,
        take: limit,
        orderBy: { createdAt: 'desc' },
      }),
      prisma.${modelLower}.count(),
    ]);

    return NextResponse.json({
      data: ${modelLower}s,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit),
      },
    });
  } catch (error) {
    console.error('Error fetching ${modelLower}s:', error);
    return NextResponse.json(
      { error: 'Failed to fetch ${modelLower}s' },
      { status: 500 }
    );
  }
}

// POST - Create ${modelLower}
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const validated = create${modelName}Schema.parse(body);

    const ${modelLower} = await prisma.${modelLower}.create({
      data: validated,
    });

    return NextResponse.json(${modelLower}, { status: 201 });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Validation failed', details: error.errors },
        { status: 400 }
      );
    }
    console.error('Error creating ${modelLower}:', error);
    return NextResponse.json(
      { error: 'Failed to create ${modelLower}' },
      { status: 500 }
    );
  }
}
`;
  }

  private generateCrudRoute(model: DataModel): string {
    const modelName = model.name;
    const modelLower = model.name.toLowerCase();

    return `import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { z } from 'zod';

// Update schema (all fields optional)
const update${modelName}Schema = z.object({
${model.fields
  .filter(f => !['id', 'createdAt', 'updatedAt'].includes(f.name))
  .map(f => `  ${f.name}: z.${this.mapToZodType(f.type)}().optional(),`)
  .join('\n')}
});

// GET - Get single ${modelLower}
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const ${modelLower} = await prisma.${modelLower}.findUnique({
      where: { id: params.id },
    });

    if (!${modelLower}) {
      return NextResponse.json(
        { error: '${modelName} not found' },
        { status: 404 }
      );
    }

    return NextResponse.json(${modelLower});
  } catch (error) {
    console.error('Error fetching ${modelLower}:', error);
    return NextResponse.json(
      { error: 'Failed to fetch ${modelLower}' },
      { status: 500 }
    );
  }
}

// PATCH - Update ${modelLower}
export async function PATCH(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const body = await request.json();
    const validated = update${modelName}Schema.parse(body);

    const ${modelLower} = await prisma.${modelLower}.update({
      where: { id: params.id },
      data: validated,
    });

    return NextResponse.json(${modelLower});
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Validation failed', details: error.errors },
        { status: 400 }
      );
    }
    console.error('Error updating ${modelLower}:', error);
    return NextResponse.json(
      { error: 'Failed to update ${modelLower}' },
      { status: 500 }
    );
  }
}

// DELETE - Delete ${modelLower}
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    await prisma.${modelLower}.delete({
      where: { id: params.id },
    });

    return new NextResponse(null, { status: 204 });
  } catch (error) {
    console.error('Error deleting ${modelLower}:', error);
    return NextResponse.json(
      { error: 'Failed to delete ${modelLower}' },
      { status: 500 }
    );
  }
}
`;
  }

  private mapToZodType(type: string): string {
    const typeMap: Record<string, string> = {
      'string': 'string',
      'number': 'number',
      'float': 'number',
      'boolean': 'boolean',
      'date': 'string', // Will be parsed as date
      'Date': 'string',
    };
    return typeMap[type.toLowerCase()] || 'string';
  }

  private generateAuthRegisterRoute(): string {
    return `import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { hash } from 'bcryptjs';
import { z } from 'zod';

const registerSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
  name: z.string().min(2),
});

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { email, password, name } = registerSchema.parse(body);

    // Check if user exists
    const existingUser = await prisma.user.findUnique({
      where: { email },
    });

    if (existingUser) {
      return NextResponse.json(
        { error: 'User already exists' },
        { status: 400 }
      );
    }

    // Hash password
    const hashedPassword = await hash(password, 12);

    // Create user
    const user = await prisma.user.create({
      data: {
        email,
        name,
        password: hashedPassword,
      },
      select: {
        id: true,
        email: true,
        name: true,
        createdAt: true,
      },
    });

    return NextResponse.json(user, { status: 201 });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Validation failed', details: error.errors },
        { status: 400 }
      );
    }
    console.error('Registration error:', error);
    return NextResponse.json(
      { error: 'Registration failed' },
      { status: 500 }
    );
  }
}
`;
  }

  private generateAuthLoginRoute(): string {
    return `import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { compare } from 'bcryptjs';
import { SignJWT } from 'jose';
import { z } from 'zod';

const loginSchema = z.object({
  email: z.string().email(),
  password: z.string(),
});

const JWT_SECRET = new TextEncoder().encode(
  process.env.JWT_SECRET || 'your-secret-key'
);

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { email, password } = loginSchema.parse(body);

    // Find user
    const user = await prisma.user.findUnique({
      where: { email },
    });

    if (!user || !user.password) {
      return NextResponse.json(
        { error: 'Invalid credentials' },
        { status: 401 }
      );
    }

    // Verify password
    const isValid = await compare(password, user.password);

    if (!isValid) {
      return NextResponse.json(
        { error: 'Invalid credentials' },
        { status: 401 }
      );
    }

    // Generate JWT
    const token = await new SignJWT({ 
      userId: user.id, 
      email: user.email,
      role: user.role,
    })
      .setProtectedHeader({ alg: 'HS256' })
      .setIssuedAt()
      .setExpirationTime('7d')
      .sign(JWT_SECRET);

    // Set cookie
    const response = NextResponse.json({
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
      },
    });

    response.cookies.set('token', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 60 * 60 * 24 * 7, // 7 days
    });

    return response;
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Validation failed', details: error.errors },
        { status: 400 }
      );
    }
    console.error('Login error:', error);
    return NextResponse.json(
      { error: 'Login failed' },
      { status: 500 }
    );
  }
}
`;
  }

  private generateMiddleware(requirements: Requirement[]): ProjectFile[] {
    const middleware: ProjectFile[] = [];

    // Auth middleware
    middleware.push({
      path: 'lib/auth.ts',
      content: `import { NextRequest } from 'next/server';
import { jwtVerify } from 'jose';

const JWT_SECRET = new TextEncoder().encode(
  process.env.JWT_SECRET || 'your-secret-key'
);

export interface AuthUser {
  userId: string;
  email: string;
  role: string;
}

export async function verifyAuth(request: NextRequest): Promise<AuthUser | null> {
  const token = request.cookies.get('token')?.value;

  if (!token) {
    return null;
  }

  try {
    const { payload } = await jwtVerify(token, JWT_SECRET);
    return payload as unknown as AuthUser;
  } catch {
    return null;
  }
}

export async function requireAuth(request: NextRequest): Promise<AuthUser> {
  const user = await verifyAuth(request);
  
  if (!user) {
    throw new Error('Unauthorized');
  }
  
  return user;
}

export async function requireRole(request: NextRequest, role: string): Promise<AuthUser> {
  const user = await requireAuth(request);
  
  if (user.role !== role) {
    throw new Error('Forbidden');
  }
  
  return user;
}
`,
      type: 'source',
      createdBy: this.profile.id,
      createdAt: new Date(),
      updatedAt: new Date(),
      version: 1,
    });

    // Rate limiting middleware
    middleware.push({
      path: 'lib/rate-limit.ts',
      content: `import { NextRequest, NextResponse } from 'next/server';

interface RateLimitConfig {
  interval: number; // in milliseconds
  limit: number;
}

const rateLimitMap = new Map<string, { count: number; lastReset: number }>();

export function rateLimit(config: RateLimitConfig = { interval: 60000, limit: 100 }) {
  return async function middleware(request: NextRequest) {
    const ip = request.ip || request.headers.get('x-forwarded-for') || 'anonymous';
    const now = Date.now();
    
    const record = rateLimitMap.get(ip);
    
    if (!record || now - record.lastReset > config.interval) {
      rateLimitMap.set(ip, { count: 1, lastReset: now });
      return null;
    }
    
    if (record.count >= config.limit) {
      return NextResponse.json(
        { error: 'Too many requests' },
        { status: 429 }
      );
    }
    
    record.count++;
    return null;
  };
}
`,
      type: 'source',
      createdBy: this.profile.id,
      createdAt: new Date(),
      updatedAt: new Date(),
      version: 1,
    });

    return middleware;
  }

  private generateUtils(): ProjectFile[] {
    const utils: ProjectFile[] = [];

    // Prisma client
    utils.push({
      path: 'lib/prisma.ts',
      content: `import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient({
  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
});

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}
`,
      type: 'source',
      createdBy: this.profile.id,
      createdAt: new Date(),
      updatedAt: new Date(),
      version: 1,
    });

    // API helpers
    utils.push({
      path: 'lib/api.ts',
      content: `import { NextResponse } from 'next/server';

export function successResponse<T>(data: T, status = 200) {
  return NextResponse.json(data, { status });
}

export function errorResponse(message: string, status = 500, details?: unknown) {
  return NextResponse.json(
    { error: message, ...(details && { details }) },
    { status }
  );
}

export function notFoundResponse(resource = 'Resource') {
  return errorResponse(\`\${resource} not found\`, 404);
}

export function unauthorizedResponse() {
  return errorResponse('Unauthorized', 401);
}

export function forbiddenResponse() {
  return errorResponse('Forbidden', 403);
}

export function validationErrorResponse(errors: unknown) {
  return errorResponse('Validation failed', 400, errors);
}
`,
      type: 'source',
      createdBy: this.profile.id,
      createdAt: new Date(),
      updatedAt: new Date(),
      version: 1,
    });

    return utils;
  }
}
